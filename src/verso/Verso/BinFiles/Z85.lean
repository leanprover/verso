/-
Copyright (c) 2025 Lean FRO LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: David Thrane Christiansen
-/

import Std.Tactic.BVDecide

set_option guard_msgs.diff true
set_option linter.missingDocs true

namespace Verso.BinFiles.Z85

/-- Z85 alphabet (85 printable ASCII characters) -/
private def alphabet : Array Char :=
  "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#".toList.toArray

/--
Lookup table for decoding characters into values.
-/
private def decodeLookup : Array Nat := Id.run do
  let mut arr := Array.replicate 256 0
  for h : i in [0:85] do
    let char := alphabet[i]
    arr := arr.set! char.toNat i
  arr


private theorem alphabet_lt_256 (h : i < 85) : alphabet[i].toNat < 256 := by
  simp only [alphabet, String.toList, List.getElem_toArray]
  rw [← List.getElem_map (f := Char.toNat) (h := h)]
  . simp
    repeat (cases ‹Nat› <;> simp [*])

/--
Finds the index of the given character in the alphabet.

Used during decoding.
-/
private def alphabetChar (i : UInt32) (h : i < 85 := by bv_decide) : Char :=
  alphabet[i.toNat]


/--
Gets the numeric value of a character.
-/
private def charValue (c : Char) : UInt32 :=
  decodeLookup[c.toNat]!

/--
Encodes 4 bytes to 5 characters.
-/
private def encodeChunk (bytes : ByteArray) (startIdx : Nat) (ok : startIdx + 3 < bytes.size := by omega) : String := Id.run do
  -- Convert 4 bytes to 32-bit value (big-endian)
  let b0 := bytes[startIdx + 0].toUInt32
  let b1 := bytes[startIdx + 1].toUInt32
  let b2 := bytes[startIdx + 2].toUInt32
  let b3 := bytes[startIdx + 3].toUInt32
  let value := (b0 <<< 24) ||| (b1 <<< 16) ||| (b2 <<< 8) ||| b3

  -- Convert to base-85 (5 digits)
  let d0 := value % 85
  let value := value / 85
  let d1 := value % 85
  let value := value / 85
  let d2 := value % 85
  let value := value / 85
  let d3 := value % 85
  let d4 := value / 85

  -- Look up characters (reverse order for big-endian)
  let c4 := alphabetChar d4
  let c3 := alphabetChar d3
  let c2 := alphabetChar d2
  let c1 := alphabetChar d1
  let c0 := alphabetChar d0

  String.mk [c4, c3, c2, c1, c0]

/-- Decodes 5 characters to 4 bytes. -/
private def decodeChunk (chars : Substring) : UInt8 × UInt8 × UInt8 × UInt8 :=
  let c0 := chars.get 0
  let c1 := chars.get ⟨1⟩
  let c2 := chars.get ⟨2⟩
  let c3 := chars.get ⟨3⟩
  let c4 := chars.get ⟨4⟩
  -- Get values for each character
  let v4 := charValue c0
  let v3 := charValue c1
  let v2 := charValue c2
  let v1 := charValue c3
  let v0 := charValue c4

  -- Convert from base-85 to 32-bit value
  let value := v4 * (85^4) + v3 * (85^3) + v2 * (85^2) + v1 * 85 + v0

  -- Extract 4 bytes (big-endian)
  let b0 := ((value >>> 24) &&& 0xFF).toUInt8
  let b1 := ((value >>> 16) &&& 0xFF).toUInt8
  let b2 := ((value >>> 8) &&& 0xFF).toUInt8
  let b3 := (value &&& 0xFF).toUInt8

  (b0, b1, b2, b3)


/-- Pads byte array to multiple of 4. -/
private def padBytes (bytes : ByteArray) : ByteArray :=
  let remainder := bytes.size % 4
  match 4 - remainder with
  | 0 => bytes
  | 1 => bytes.push 0
  | 2 => bytes.push 0 |>.push 0
  | 3 => bytes.push 0 |>.push 0 |>.push 0
  | _ => bytes

@[simp]
theorem byteArray_push_size (xs : ByteArray) : (xs.push x).size = xs.size + 1 := by
  simp [ByteArray.push, ByteArray.size]

private theorem padBytes_size_mod_4 : (padBytes xs).size % 4 = 0 := by
  fun_cases padBytes
  case case1 rem h =>
    omega
  case case2 | case3 | case4 =>
    simp; omega
  case case5 rem h0 h1 h2 h3 =>
    simp_all [rem]
    match h' : xs.size with
    | 0 | 1 | 2 | 3 => simp_all
    | k + 4 => simp_all; omega

/-- Removes padding from decoded bytes. -/
private def removePadding (bytes : ByteArray) (originalSize : Nat) : ByteArray :=
  bytes.extract 0 originalSize


/--
Encodes an array to a Z85 string, which losslessly encodes binary data using only printable ASCII.
In particular, Z85 strings are safe as string literals in C code generated by Lean.

Correctly decoding the array will require its size.
-/
def encode (data : ByteArray) : String := Id.run do
  if data.isEmpty then
    return ""

  let paddedData := padBytes data
  have : paddedData.size % 4 = 0 := by simp [padBytes_size_mod_4, paddedData]

  let chunks := paddedData.size / 4

  let mut result := ""

  for h : i in [0:chunks] do
    let startIdx := i * 4

    let encoded ← encodeChunk paddedData startIdx <| by
      cases h
      simp_all
      omega
    result := result ++ encoded

  result

/--
Decodes a Z85 string. Returns garbage if the string is not a valid Z85 encoding.
-/
def decode (encoded : String) (originalSize : Nat) : ByteArray := Id.run do
  if encoded.isEmpty then
    return .empty

  if encoded.length % 5 != 0 then
    panic! s!"Invalid length {encoded.length}"
  else
    let chunks := encoded.length / 5
    let mut result : ByteArray := .emptyWithCapacity (originalSize + 4)

    for i in [0:chunks] do
      let startIdx := i * 5
      let (a, b, c, d) ← decodeChunk {str := encoded, startPos := ⟨startIdx⟩, stopPos := ⟨startIdx + 5⟩}
      result := result |>.push a |>.push b |>.push c |>.push d

    (removePadding result originalSize)

section Test

private def ofArray (xs : Array UInt8) : ByteArray :=
  xs.foldl (init := ByteArray.emptyWithCapacity xs.size) ByteArray.push

-- Test functions
private def testEncode : IO Unit := do
  let testData : Array UInt8 := #[72, 101, 108, 108, 111]  -- "Hello"
  let encoded := encode (ofArray testData)
  IO.println s!"Encoded: {encoded}"


private def testDecode : IO Unit := do
  let testEncoded := "By/JnwmoN*"
  let decoded := decode testEncoded 8
  IO.println s!"Decoded bytes: {decoded}"
  -- Convert back to string for verification
  let chars := decoded.toList.map (fun b => Char.ofUInt8 b)
  IO.println s!"Decoded string: {String.mk chars}"

private def testRoundTrip : IO Unit := do
  let original : Array UInt8 := #[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]  -- "Hello World!"
  let encoded := encode (ofArray original)
  IO.println s!"Original: {original}"
  IO.println s!"Encoded: {encoded}"

  let decoded := decode encoded original.size
  IO.println s!"Decoded: {decoded}"
  IO.println s!"Round trip successful: {original == decoded.toList.toArray}"


private local instance : BEq ByteArray where
  beq xs ys :=
    if h : xs.size = ys.size then
      xs.size.all fun i h => xs[i] = ys[i]
    else
      false

private def testRoundTripOf (original : ByteArray) : IO Unit := do
  let encoded := encode original
  let decoded := decode encoded original.size
  unless original == decoded do
    throw <| .userError "Mismatch"

private def test : IO Unit := do
  testEncode
  testDecode
  testRoundTrip
  IO.setRandSeed 5
  for i in [0:15] do
    let arr ← i.foldM (init := ByteArray.empty) fun _ _ xs => (xs.push <| UInt8.ofNat ·) <$> (IO.rand 0 256)
    testRoundTripOf arr


/--
info: Encoded: nm=QNzVx+q
Decoded bytes: [116, 101, 115, 116, 100, 97, 116, 97]
Decoded string: testdata
Original: #[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]
Encoded: nm=QNzY&b1A+]nf
Decoded: [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]
Round trip successful: true
-/
#guard_msgs in #eval test

end Test
